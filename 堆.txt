//最大/小堆,区别tmp和arr[j]大小比较换一下就会由小堆变大堆,堆是一种经过排序的完全二叉树，其中任一非终端节点的数据值均不大于（或不小于）其左孩子和右孩子节点的值。
#include<iostream>
using namespace std;
//上调算法,从下往上走 

void fix_up_min_heap(int arr[],int i)//把当前第i个子节点进行向上调整
{
   int j;
   j=(i-1)/2;//父结点
   int tmp=arr[i];
   while(j>=0&&tmp>arr[j])
   {
        arr[i]=arr[j];
		i=j;
		if(j>0)
			j=(j-1)/2;
		else
			break;
   }
   arr[i]=tmp;
}
//下滑算法,从上向下调整
void fix_down_min_heap(int arr[],int len,int i)//len当前长度,而数组元素是从0开始的
{
  int j;
  j=2*i+1;
  int tmp=arr[i];
  while(j<len)
  {
     if(j<len-1&&arr[j+1]>arr[j])//保证不会数组越界
		 j++;
	 if(arr[j]>tmp)
	 {
		 arr[i]=arr[j];
		 i=j;
		 j=2*i+1;
	 }
	 else
		 break;
  }
  arr[i]=tmp;
}
//堆插入,插入尾部，每次要和父结点比较，用上调算法
int insert_min_heap(int arr[],int n,int len,int x)//当前元素个数len,n总共元素个数
{
  if(n==len)return -1;
  arr[len++]=x;
  fix_up_min_heap(arr,len-1);
  return 1;
}
//取堆顶
int top_min_heap(int arr[])
{
   return arr[0];
}
//堆删除,把最后一个元素覆盖到堆顶，然后做下调算法
void pop_min_heap(int arr[],int len)
{
  arr[0]=arr[--len];
  fix_down_min_heap(arr,len,0);
}
int main()
{   
    int p[7];
	int t;
	for(int i=0;i<7;i++)
	{
		cin>>p[i];
        t=i;
        insert_min_heap(p,7,t,p[i]);
	}

	for(i=0;i<7;i++)
		cout<<p[i]<<' ';
	for(i=7;i>0;i--)

	{   
		t=i;
		cout<<top_min_heap(p);
		pop_min_heap(p,t);
		
	}
	
	return 0;
}